##################################### utils ####################################
graycode ← ι=> ι b^ (ι>>1)
graycode.⁻¹ = ι=>{
	if (ι===0) ↩ ι
	m ← ceil(log2(ι)) + 1
	i ← x; for(j←1;j<m;j++) i b^= x>>j
	↩ i }
rrot ← (x,i,x_bit_width)=>{ L ← x_bit_width
	x < 2**L || ‽
	i %= L
	x = (x >> i) | (x << L-i)
	↩ x & 2**L-1 }
lrot ← (x,i,x_bit_width)=>{ L ← x_bit_width
	x < 2**L || ‽
	i %= L
	x = (x<<i) | (x >> L-i)
	↩ x & 2**L-1 }
tsb ← (x,x_bit_width)=>{ L ← x_bit_width # trailing set bits
	x < 2**L || ‽
	for(i ← 0; (x&1)!==0 && i <= L; i++) x >>= 1
	↩ i }
setbit ← (x,w,i,b)=>{ # sets bit i in an integer x of width w to b
	b===0 || b===1 || ‽
	i < w || ‽
	m ← 2**(w-i-1)
	↩ b? x | m : x & ~m }
bitrange ← (x,width,start,end)=> # Extract a bit range as an integer. (start, end) is inclusive lower bound, exclusive upper bound.
	x >> width-end & 2**(end-start)-1

#################################### hilbert ###################################
transform ← (entry,direction,width,x)=>{
	x < 2**width || ‽
	entry < 2**width || ‽
	↩ rrot(x b^ entry, direction+1, width) }
transform.⁻¹ = (entry,direction,width,x)=>{
	x < 2**width || ‽
	entry < 2**width || ‽
	↩ lrot(x, direction+1, width) b^ entry
	# There is an error in the Hamilton paper's formulation of the inverse transform in Lemma 2.12. The correct restatement as a transform is as follows:
	# ↩ transform(rrot(entry, direction+1, width), width-direction-2, width, x)
	}
direction ← (x,n)=>{
	x < 2**n || ‽
	↩ x===0? 0
		: x%2===0? tsb(x-1,n) % n
		: tsb(x,n) % n }
entry ← x=> x===0? 0 : graycode(((x-1)/2 |0)*2)

index_to_point ← (dimension,order,h)=>{
	if (dimension===2) ↩ fast_itp2(2**order,h)
	# The bit widths in this function are:
	#     p[*]  - order
	#     h     - order*dimension
	#     l     - dimension
	#     e     - dimension
	hwidth ← order*dimension
	e←0; d←0
	p ← Array(dimension).fill(0)
	for(i←0;i<order;i++){
		w ← bitrange(h, hwidth, i*dimension, i*dimension+dimension)
		l ← graycode(w)
		l = transform.⁻¹(e, d, dimension, l)
		for(j←0;j<dimension;j++){
			b = bitrange(l, dimension, j, j+1)
			p[j] = setbit(p[j], order, i, b)
			}
		e b^= lrot(entry(w), d+1, dimension)
		d = (d + direction(w, dimension) + 1)%dimension
		}
	↩ p }

point_to_index ← (dimension,order,p)=>{
	if (dimension===2) ↩ fast_pti2(2**order,p[0],p[1])
	h←0; e←0; d←0
	for(i←0;i<order;i++){
		l ← 0
		for(x←0;x<dimension;x++){
			b = bitrange(p[dimension-x-1], order, i, i+1)
			l |= b<<x
			}
		l = transform(e, d, dimension, l)
		w = graycode.⁻¹(l)
		e = e b^ lrot(entry(w), d+1, dimension)
		d = (d + direction(w, dimension) + 1)%dimension
		h = (h<<dimension)|w
		}
	↩ h }

##################################### fast #####################################
fast_pti2 ← (n,x,y)=>{
	log2(n)%1===0 || ‽
	d ← 0
	for(s←n/2;s>0;s/=2){
		rx ← x&s > 0
		ry ← y&s > 0
		d += s*s * ((3*rx) b^ ry)
		if (ry===0) [x,y] = ( (rx===1? (x = s-1 - x, y = s-1 - y) : 0), [y,x] )
		}
	↩ d}
fast_itp2 ← (n,d)=>{
	log2(n)%1===0 || ‽
	x ← 0; y ← 0
		for(s←1;s<n;s*=2){
			rx ← 1 & (d/2)
			ry ← 1 & (d b^ rx)
			;[x,y] = ry!==0? [x,y] :( (rx===1? (x = s-1 - x, y = s-1 - y) : 0), [y,x] )
			x += s * rx
			y += s * ry
			d /= 4
		}
		↩ [y,x] }

module.exports = { index_to_point, point_to_index, }
