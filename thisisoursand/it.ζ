############################## nice-to-have todos ##############################
# use facebook api to get a list of your friends who also play this_is_our_sand
# http://xirsys.com/ TURN server
# bug: shit gets weird on the right
# favicon
# if you click on an invisible area use a nearby color instead of black, also show which nearby color will be chosen
# simple animations

################# color ################
# use http://gramaz.io/d3-cam02/ 
# does it fix https://en.wikipedia.org/wiki/Helmholtz%E2%80%93Kohlrausch_effect ?

################################### builtins ###################################
global ‚Üê window
Œ≥ ‚Üê global
E ‚Üê Œ≥
E.êÖØSet = (‚Ä¶Œπ)=> new Set(Œπ)
E._u = E._ = require('underscore')
‚ãØ ‚Üê Œπ=> _u.range(Œπ)
‚âà ‚Üê _u.isEqual
‚ââ ‚Üê (a,b)=> ! ‚âà(a,b)
Object.defineProperty(Array.prototype,'_',{get:Œª(){‚Ü© _(@) }, configurable:true})
Object.defineProperty(Array.prototype,'‚Äñ',{get:Œª(){‚Ü© @.length }, configurable:true})
Object.defineProperty(Array.prototype,'-1',{get(){‚Ü© @.‚Äñ<1? ‚àÖ : @[@.‚Äñ-1] },set(Œπ){ @.‚Äñ<1 || (@[@.‚Äñ-1] = Œπ) }, configurable:true})
Object.defineProperty(Function.prototype,'X',{get(){ Œπ‚Üê@; ‚Ü© Œª(a){‚Ü© Œπ.call(@,a) } }, configurable:true})
cn ‚Üê {log:(‚Ä¶a)=>console.log(‚Ä¶a)}
_(E).assign(_(Math).pick('abs','ceil','exp','floor','log10','log2','max','min','round','sqrt','cos','sin','tan'),{ln:Math.log, œÄ:Math.PI, œÑ:Math.PI*2})
Tnum ‚Üê Œπ=> typeof Œπ === 'number'
Tfun ‚Üê Œπ=> typeof Œπ === 'function'
random ‚Üê Œª(Œπ){‚Ü© arguments.length===0? Math.random() : Tnum(Œπ)? random()*Œπ |0 : _.sample(Œπ) }
Œ† ‚Üê Œπ=> Tfun(Œπ) && /^(yes|\(yes,no\))=>/.test(Œπ+'')? new Promise(Œπ) : Promise.resolve(Œπ)
def ‚Üê (o,name,Œπ)=>{
	if (Tfun(Œπ)) Œπ = lazy(name,Œπ)
	'configurable' in Œπ || (Œπ.configurable = true)
	'value' in Œπ?
		'writable' in Œπ || (Œπ.writable = true) :
		'set' in Œπ || (Œπ.set = Œª(Œπ){ def(@,name,{value:Œπ, enumerable:true}) })
	Object.defineProperty(o,name,Œπ); ‚Ü© o }
__err_format ‚Üê (‚Ä¶a)=> Error(a.map(Œπ=> Tstr(Œπ)? Œπ : util_inspect_autodepth(Œπ)).join(' '))
color ‚Üê require('color')
color.interpolate_0 = (c,x)=>{ x *= c.‚Äñ; i ‚Üê x|0; r ‚Üê x-i; ‚Ü© c[i%c.‚Äñ].mix(c[(i+1)%c.‚Äñ], 1-r) }
Object.defineProperty(color.prototype,'i',{get(){ Œπ ‚Üê @.rgb().color; ‚Ü© ( Œπ[0]<<24 | Œπ[1]<<16 | Œπ[2]<<8 | 0xff )>>>0 }})

##################################### utils ####################################
hilbert_curve ‚Üê require('./hilbert_curve')
AC ‚Üê new AudioContext()

get_mouse_pos ‚Üê e=>{ t ‚Üê $(e.target).offset(); ‚Ü© { x:e.pageX-t.left, y:e.pageY-t.top, time_nonstandard:e.timeStamp/1e3 } }

make_audio_buffer ‚Üê url=> Œ†((yes,no)=>{ req ‚Üê new XMLHttpRequest(); req.open('GET',url); req.responseType = 'arraybuffer'; req.onload = => AC.decodeAudioData(req.response,yes,no); req.onerror = no; req.send() })
loop_gapless_e_play_e_volume ‚Üê url=>
	make_audio_buffer(url).then(buffer=>{
		a ‚Üê AC.createBufferSource(); a.buffer = buffer; a.loop = true; a.loopStart = 0.1; a.loopEnd = buffer.duration-0.1
		b ‚Üê AC.createGain()
		a.connect(b); b.connect(AC.destination)
		a.start()
		r ‚Üê def({},'volume',{ get(){‚Ü© b.gain.value }, set(Œπ){ b.gain.value = Œπ } })
		r.volume = 0
		‚Ü© r })

perf_now ‚Üê Œπ=> ( performance.timing.navigationStart + (Œπ===‚àÖ? performance.now() : Œπ) )/1e3
mk_img ‚Üê (X,Y)=>{
	ui8c ‚Üê new Uint8ClampedArray(X*Y*4)
	dv ‚Üê new DataView(ui8c.buffer)
	‚Ü© {
	X, Y, ImageData:new ImageData(ui8c,X,Y),
	get(x,y){‚Ü© dv.getUint32( (y*X + x)*4 ) },
	set(x,y,Œπ){ dv.setUint32( (y*X + x)*4, Tnum(Œπ)? Œπ : color(Œπ).i ) },
	clear(){ ui8c.fill(0) }
	} }

timing ‚Üê []
do_timing ‚Üê Œπ=>{
	at ‚Üê perf_now()
	timing.push({at,Œπ})
	for(i‚Üê0;i<timing.‚Äñ;i++) if( timing[i].at >= at-5 ) break ;timing.splice(0,i)
	effective_len ‚Üê at - timing[0].at
	$('.fps').html(`fps: ${timing.filter(.Œπ==='frame')['‚Äñ'] / effective_len |0}<br>tps: ${timing.filter(.Œπ==='tick')['‚Äñ'] / effective_len |0}`)
	}
frame_done ‚Üê => do_timing('frame')
tick_done ‚Üê => do_timing('tick')

# {nk,norm‚àû_affine_sorted_E} ‚Üê numeric2
# interpolate_mouse_places ‚Üê (Œπ,L)‚áí
# 	: Œπ.‚Äñ===0? []
# 	: Œπ.‚Äñ===1? ‚ãØ(L).map(=> [Œπ[0].x,Œπ[0].y])
# 	: nk.spline( norm‚àû_affine_sorted_E(Œπ.map(.time_nonstandard)), Œπ.map(Œπ=> [Œπ.x,Œπ.y]) )
# 		.at(nk.linspace(0,1,L))
numeric ‚Üê require('numeric')
norm_eq ‚Üê l=>{ numeric.subeq(l,l[0]) ;numeric.diveq(l,l[-1]) ;‚Ü© l }
interpolate_mouse_places ‚Üê (Œπ,L)‚áí
	: Œπ.‚Äñ===0? []
	: Œπ.‚Äñ===1? ‚ãØ(L).map(=> [Œπ[0].x,Œπ[0].y])
	: numeric.spline( norm_eq(Œπ.map(.time_nonstandard)), Œπ.map(Œπ=> [Œπ.x,Œπ.y]) )
		.at(numeric.linspace(0,1,L))

shake_luminosity ‚Üê Œπ=>{ bright ‚Üê ( random()*(0.1 - (-0.1)) - 0.1 ) + 1; ‚Ü© color.rgb(Œπ.rgb().color.map(Œπ=> ( bright <= 1? Œπ * bright : 255 - (255 - Œπ) * (1/bright) )|0)) } # Œπ + (255 - Œπ) * (bright - 1)

convert ‚Üê { rgb:{}, xyz:{}, lab:{}, luv:{}, }
convert.rgb.xyz = rgb=>{
	[r,g,b] ‚Üê rgb.map(Œπ=> Œπ/255)
		.map(Œπ=> Œπ > 0.04045? ((Œπ + 0.055) / 1.055)**2.4 : Œπ/12.92 ) # assume sRGB
	‚Ü© [
		r*0.4124 + g*0.3576 + b*0.1805,
		r*0.2126 + g*0.7152 + b*0.0722,
		r*0.0193 + g*0.1192 + b*0.9505,
		].map(Œπ=> Œπ*100) }
convert.xyz.lab = xyz=>{ [x,y,z] ‚Üê xyz
	x /= 95.047; y /= 100; z /= 108.883
	[x,y,z] ‚Üê [x,y,z].map(Œπ=> Œπ > 0.008856? Œπ**(1/3) : 7.787*Œπ + 16/116 )
	‚Ü© [ (116 * y) - 16, 500 * (x - y), 200 * (y - z) ] }
convert.lab.xyz = lab=>{ [l,a,b] ‚Üê lab
	# sRGB: L ‚àà [0,100] a ‚àà [-85,97] b ‚àà [-106,94]
	y ‚Üê (l + 16) / 116; x ‚Üê a / 500 + y; z ‚Üê y - b / 200
	[x,y,z] ‚Üê [x,y,z].map(Œπ=>{ Œπ2 ‚Üê Œπ**3; ‚Ü© Œπ2 > 0.008856 ? Œπ2 : (Œπ - 16/116) / 7.787 })
	x *= 95.047; y *= 100; z *= 108.883
	‚Ü© [x,y,z] }
convert.xyz.rgb = xyz=>{
	[x,y,z] ‚Üê xyz.map(Œπ=> Œπ/100)
	r ‚Üê x* 3.2406 + y*-1.5372 + z*-0.4986
	g ‚Üê x*-0.9689 + y* 1.8758 + z* 0.0415
	b ‚Üê x* 0.0557 + y*-0.2040 + z* 1.0570
	‚Ü© [r,g,b].map(Œπ=> Œπ > 0.0031308? 1.055*Œπ**(1/2.4) - 0.055 : Œπ*12.92 ) # assume sRGB
		# .map(Œπ=> min(max(0,Œπ),1))
		.map(Œπ=> Œπ*255) }

################################################################################
$(document).ready(=>{
################################################################################
SAND_PER_TICK ‚Üê 25
TOOL_LENGTH ‚Üê 5# 30 # seconds

frame_pool ‚Üê Set()

picked_colors‚Üê; set_picked_colors(['#800','#666','#fff'])
tool_time ‚Üê 0; tool_length ‚Üê => TOOL_LENGTH * 60/*fps*/ * SAND_PER_TICK * picked_colors.‚Äñ
gen_color ‚Üê => shake_luminosity(color.interpolate_0(picked_colors, (tool_time++) / tool_length() % 1))

sound ‚Üê (=>{
	a‚Üê; loop_gapless_e_play_e_volume('pink_noise.mp3').then(Œπ=> a = Œπ)
	‚Ü© {
	fade_out: => frame_pool.add(Œª self(){ if (!a) ‚Ü©; a.volume *= 0.9; if (a.volume < 0.01){ a.volume = 0; frame_pool.delete(self) } }),
	adjust_volume: Œπ=> a &&( a.volume = min(max(0, a.volume + (Œπ - a.volume)*0.175 ),1) ),
	} })()

################################################################################
Œª set_color_picker_icon(){
	d ‚Üê $('.chooser').css('width').match(/^\d+/)[0]|0
	$('.chooser').html( picked_colors.map((col,i,l)=>{ L ‚Üê l.‚Äñ; d2 ‚Üê round(d * (L-i)/L /2)*2; ‚Ü© $('<div class="chooser_elem">').css({width:d2+'px',height:d2+'px','background-color':col.string()}) }) )
	}
Œª set_picked_colors(Œπ){ picked_colors = Œπ.map(color.X); set_color_picker_icon() }

$('.chooser').click(=>{ colorset.show() })
$('.colorset > canvas').click(e=>{
	t ‚Üê $('.colorset > canvas').offset()
	set_picked_colors([colorset().get({ x:e.pageX-t.left, y:e.pageY-t.top, time_nonstandard:e.timeStamp/1e3 })])
	colorset.hide()
	})

sand_world ‚Üê (=>{
	canvas ‚Üê $('.sandbox > canvas')[0]

	mouse_places ‚Üê []
	on_because‚Üê;
	go_on ‚Üê e=>{ mouse_places.push(get_mouse_pos(e)); $(canvas).on('mousemove',e=>{ mouse_places.push(get_mouse_pos(e)) }) }
	go_off ‚Üê =>{ mouse_places = []; $(canvas).off('mousemove') }
	$(canvas)
		.mousedown(e=>{ on_because = 'mousedown'; go_on(e) })
		.mouseup(go_off)
		.mouseenter(e=>{ ((e.buttons&0x1) || on_because==='dblclick') && go_on(e) })
		.mouseleave(go_off)
		.dblclick(e=>{ on_because = 'dblclick'; go_on(e) })

	# time_at_last ‚Üê perf_now()
	state_init ‚Üê =>{
		shape ‚Üê { X:canvas.clientWidth, Y:canvas.clientHeight }
		buffer‚Üê;
		particles ‚Üê []
		voxel_states ‚Üê (=>{
			vk ‚Üê ['empty','static','in_air','stacking']
			kv ‚Üê _(vk).pairs().map(Œπ=>[Œπ[1],Œπ[0]|0])._.object()
			‚Ü© {
			Œπ: new Uint8Array(shape.X*shape.Y),
			get(x,y){‚Ü© vk[ 0<=x && x<shape.X && 0<=y && y<shape.Y? @.Œπ[y*shape.X+x] : 1 ] },
			set(x,y,Œπ){ if (0<=x && x<shape.X && 0<=y && y<shape.Y) @.Œπ[y*shape.X+x] = kv[Œπ] },
			} })()
		canvas.width = shape.X ;canvas.height = shape.Y
		‚Ü© { shape, buffer, particles, voxel_states, } }

	state ‚Üê state_init()

	find_noncolliding_y ‚Üê (xi,y)=>{ yi ‚Üê round(y); {shape,voxel_states} ‚Üê state
		if (!(0 <= yi) || yi===0) yi = y = 0
		if (!(yi < shape.Y)) ‚Ü© shape.Y - 1
		for(;;){ t ‚Üê voxel_states.get(xi,yi); if (t==='empty' || t==='in_air') ‚Ü© y; if (!(yi < shape.Y)) ‚Ü© shape.Y - 1; y += 1; yi += 1 }
		}

	mk_particle ‚Üê (pos,color)=>{ {shape,particles} ‚Üê state
		new_y ‚Üê find_noncolliding_y(pos.x,pos.y)
		p ‚Üê {
			status:'',
			color: color || gen_color().i,
			x: max(0,min(shape.X,pos.x)),
			y: max(0,min(shape.Y,new_y)) + (new_y===pos.y? 0 : 1),
			vx: (random() - 0.5) * 3,
			vy: random()*2 + (new_y===pos.y? 0 : 6 + 7 * (new_y-pos.y)/shape.Y),
			}
		particles.push(p)
		place_particle(p)
		}
	take_particle ‚Üê p=>{ {voxel_states} ‚Üê state; ‚Ü© voxel_states.get(round(p.x),round(p.y))==='static' || voxel_states.set(round(p.x),round(p.y),'empty') }
	place_particle ‚Üê p=>{ low__0‚Üê; {voxel_states} ‚Üê state
		x ‚Üê round(p.x); y ‚Üê round(p.y)
		if (p.vy > 0)
			p.status = 'in_air'
		else if((low__0=voxel_states.get(x+0,y-1))==='empty' || low__0==='in_air')
			p.status = 'in_air'
		else if(low__0==='static' && voxel_states.get(x-1,y-1)==='static' && voxel_states.get(x+1,y-1)==='static')
			p.status = 'static'
		else
			{ p.vy = 0; p.status = 'stacking' }
		voxel_states.set(x,y,p.status)
		}

	run_physics_tick ‚Üê =>{t‚Üê; {shape,particles,voxel_states} ‚Üê state
		count_ground_hits ‚Üê 0
		for(p‚Üê of particles){
			if(p.status==='in_air') {
				take_particle(p)
				p.x += p.vx; p.y += p.vy
				if (!(0 <= p.x && p.x < shape.X)){ b ‚Üê p.x < 0? 0 : shape.X-1; p.x = b - (p.x - b); p.vx *= -1 }
				p.y = find_noncolliding_y(round(p.x),p.y)
				p.vy -= 0.8 # gravity
				p.vx *= 0.999 # friction
				place_particle(p)
				if(p.status==='static' || p.status==='stacking') count_ground_hits++
				}
			else if(p.status==='stacking') {
				find_drop_point ‚Üê p=>{
					if(!(0 <= p.y)) ‚Ü©;
					tx ‚Üê { l:round(p.x)-1, r:round(p.x)+1 }
					ty ‚Üê round(p.y)-1
					found ‚Üê { l:!(0<=tx.l), r:!(tx.r<shape.X) }
					for(c‚Üê of ['l','r']){
						p_below ‚Üê !found[c]? voxel_states.get(tx[c],ty) : ‚àÖ
						if(!found[c]) found[c] = p_below!=='empty' && p_below!=='in_air'
						}
					if(found.l && found.r) ‚Ü©;
					ty_ ‚Üê {l:ty,r:ty}
					for(;0 <= ty;ty--) {
						for(c‚Üê of ['l','r'])
							if(!found[c]) {
								ty_[c] = ty
								p_below ‚Üê voxel_states.get(tx[c],ty)
								if(p_below!=='empty' && p_below!=='in_air')
									found[c] = true
							}
						if(found.l && found.r) break
						}
					if(ty===-1) for(c‚Üê of ['l','r']) if(!found[c]) { found[c] = true; ty_[c] = -1 }
					if(found.l && found.r) {
						‚Ü© ty_.l < ty_.r || ty_.l===ty_.r && p.vx < 0?
							{ x:p.x-1, y:ty_.l+1 }
							: { x:p.x+1, y:ty_.r+1 }
					}
					for(c‚Üê of ['l','r']) if(found[c]) ‚Ü© { x: p.x + (c==='l'? -1 : 1), y: ty_[c]+1 }
					}
				take_particle(p)
				if(t=find_drop_point(p)) {
					p.x = t.x; p.y = t.y
					if (!(0 <= p.x && p.x < shape.X)) p.x = min(max( 0,p.x),shape.X )
					}
				place_particle(p)
				}
			}
		tick_done()
		‚Ü© {count_ground_hits} }

	‚Ü© {
	mk_particle,
	run_physics_to(now){t‚Üê; {shape,particles} ‚Üê state
		# tick_length ‚Üê 1/50
		# ticks ‚Üê floor((now - time_at_last) / tick_length)
		# time_at_last += ticks * tick_length
		# if (ticks > 7){ console.log('too many ticks:',ticks); ticks = 7 }
		# for(‚Å±‚Üê0;‚Å±<ticks;‚Å±++){ ... }

		for(pos‚Üê of interpolate_mouse_places( (t = mouse_places, mouse_places = t.slice(-1), t), SAND_PER_TICK ))
			mk_particle({ x:round(pos[0]), y:shape.Y-1-round(pos[1]) })
		{count_ground_hits} ‚Üê run_physics_tick()
		# particles = particles.filter(.status!=='static')
		if(! particles.filter(.status!=='static').‚Äñ ) sound.fade_out()
		else sound.adjust_volume(count_ground_hits / SAND_PER_TICK / 2)
		},
	render(now){
		{shape,buffer,particles,voxel_states} ‚Üê state

		if (‚ââ(shape,{ X:canvas.clientWidth, Y:canvas.clientHeight })){
			old ‚Üê state
			state = state_init(); {shape,buffer,particles,voxel_states} ‚Üê state
			particles = state.particles = old.particles.filter(Œπ=> 0<=round(Œπ.x) && round(Œπ.x)<shape.X && 0<=round(Œπ.y) && round(Œπ.y)<shape.Y)
			for(y‚Üê0;y<min(shape.Y,old.shape.Y);y++)
			for(x‚Üê0;x<min(shape.X,old.shape.X);x++)
				voxel_states.set(x,y,old.voxel_states.get(x,y))
			}

		@.run_physics_to(now)

		if (!buffer) buffer = mk_img(shape.X,shape.Y); else buffer.clear()
		for(p‚Üê of particles) buffer.set( round(p.x),shape.Y-1-round(p.y), p.color )
		ctx ‚Üê canvas.getContext('2d')
		ctx.putImageData(buffer.ImageData,0,0)
		},
		} })()

# colorset ‚Üê _.memoize(Œª(){
# 	r ‚Üê {}
# 	r.$ = $('.colorset')
# 	r.$canvas = r.$.children('canvas')
# 	r.canvas = r.$canvas[0]
# 	;[r.cX,r.cY] = [r.canvas.width,r.canvas.height] = [r.$canvas.width()>>3,r.$canvas.height()>>2]
# 	r.buffer = mk_img(r.cX,r.cY)

# 	for (y‚Üê0;y<r.cY;y++)
# 	for (x‚Üê0;x<r.cX;x++){
# 		L ‚Üê 100 * (1-y/r.cY)
# 		h_i ‚Üê x/r.cX
# 		a ‚Üê 128 * cos(h_i*œÑ) * 0.5
# 		b ‚Üê 128 * sin(h_i*œÑ) * 0.5
# 		c ‚Üê convert.xyz.rgb(convert.lab.xyz([L,a,b])).map(Œπ=> Œπ<0? 0 : Œπ>0xff? 0xff : Œπ|0)
# 		r.buffer.set(x,y,c)
# 		}
# 	ctx2d ‚Üê r.canvas.getContext('2d')
# 	ctx2d.putImageData(r.buffer.ImageData,0,0)
# 	r.get = ({x,y})=>{
# 		x = x / r.$canvas.width() * r.cX |0
# 		y = y / r.$canvas.height() * r.cY |0
# 		t ‚Üê r.buffer.get(x,y)
# 		if (Tnum(t)){ r_ ‚Üê color(t>>>8); r_.valpha = (t&0xff)/0xff; ‚Ü© r_ }else ‚Ü© color(t) }
# 	‚Ü© r })
colorset ‚Üê _.once(=>{
	r ‚Üê {}
	r.$ = $('.colorset')
	r.$canvas = r.$.children('canvas')
	r.canvas = r.$canvas[0]
	# ;[r.cX,r.cY] = [r.canvas.width,r.canvas.height] = [r.$canvas.width()<<1,r.$canvas.height()<<1]
	;[r.cX,r.cY] = [r.canvas.width,r.canvas.height] = [r.$canvas.width()<<1,r.$canvas.height()*2/3|0]
	r.buffer = mk_img(r.cX,r.cY)
	squish ‚Üê 1
	columns ‚Üê
	_u.range(0,128*128,squish).map(color_i=>{
		column_pair ‚Üê
		_u.range(color_i,color_i+squish).map(color_i=>{
			[a,b] ‚Üê hilbert_curve.index_to_point(2,7,color_i).map(Œπ=>Œπ/127)
			a = a*(94+106)-85-((94+106)-(97+85))/2; b = b*(94+106)-106
			‚Ü© _u.range(100+1).map(L=>{ t ‚Üê convert.xyz.rgb(convert.lab.xyz([L,a,b])); ‚Ü© !t.every(Œπ=> 0<=Œπ&&Œπ<=0xff)? ‚àÖ : t.map(Œπ=>Œπ|0) }) })
		‚Ü© _.zip(‚Ä¶column_pair)._.flatten(true) })
	oi ‚Üê 0
	columns.filter(.some(Œπ=>Œπ)).forEach(c=>{
		x ‚Üê oi % r.cX |0
		y_ ‚Üê (oi / r.cX |0) * c.‚Äñ
		for (L‚Üê0;L<c.‚Äñ;L++)
			{ y ‚Üê y_ + c.‚Äñ-1-L; if (y < r.cY && c[L]) r.buffer.set( x,y, c[L] ) }
		oi++
		})

	ctx2d ‚Üê r.canvas.getContext('2d')
	ctx2d.putImageData(r.buffer.ImageData,0,0)
	r.get = ({x,y})=>{
		x = x / r.$canvas.width() * r.cX |0
		y = y / r.$canvas.height() * r.cY |0
		t ‚Üê r.buffer.get(x,y)
		if (Tnum(t)){ r_ ‚Üê color(t>>>8); r_.valpha = (t&0xff)/0xff; ‚Ü© r_ }else ‚Ü© color(t) }
	‚Ü© r })
colorset.show = =>{ $('.colorset').css({display:'unset'}); colorset() }
colorset.hide = =>{ $('.colorset').css({display:'none'}) }

requestAnimationFrame(Œª self(now){ now = perf_now(now)
	frame_pool.forEach(f=> f())
	sand_world.render(now)
	frame_done(); requestAnimationFrame(self) })

################################################################################
})

# http://alice.sh/thisisoursand/
# https://commons.wikimedia.org/wiki/File:SRGB_gamut_within_CIELAB_color_space_isosurface.png
